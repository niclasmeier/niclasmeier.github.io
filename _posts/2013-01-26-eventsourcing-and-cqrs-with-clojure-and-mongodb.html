---
layout: post
status: publish
published: true
title: Eventsourcing and CQRS with Clojure and MongoDB
author:
  display_name: Niclas Meier
  login: niclas
  email: mail@niclas-meier.de
  url: http://www.niclas-meier.de
author_login: niclas
author_email: mail@niclas-meier.de
author_url: http://www.niclas-meier.de
excerpt: "It was about a year ago when I stumbled about the concepts of <a href=\"http:&#47;&#47;martinfowler.com&#47;eaaDev&#47;EventSourcing.html\">event
  sourcing<&#47;a> and <a href=\"http:&#47;&#47;martinfowler.com&#47;bliki&#47;CQRS.html\">command
  query responsibility segregation<&#47;a> in a talk from <a href=\"http:&#47;&#47;codebetter.com&#47;gregyoung&#47;\">Greg
  Young<&#47;a> at QCon 2011 in London which I watched on <a href=\"http:&#47;&#47;www.infoq.com&#47;presentations&#47;Events-Are-Not-Just-for-Notifications\">InfoQ<&#47;a>.
  This challenged some things I knew for sure regarding how to store and manage data.
  \r\n\r\nFortunately I joined <a href=\"http:&#47;&#47;herolabs.com\">HEROLABS<&#47;a>
  in December 2011 and due to the fact that we where starting a brand new product,
  I was able to play around with these concepts. Additionally we chose <a href=\"http:&#47;&#47;www.mongodb.org&#47;\">MongoDB<&#47;a>
  instead of a relational database in our <a href=\"http:&#47;&#47;itunes.apple.com&#47;de&#47;app&#47;em-hero-2012&#47;id530513702?l=de&ls=1&mt=8\">first
  project<&#47;a> as our main database management system. <a href=\"http:&#47;&#47;www.mongodb.org&#47;\">MongoDB<&#47;a>
  is attributed to the NoSQL databases and is in the first place a big document (<a
  href=\"http:&#47;&#47;json.org\">JSON<&#47;a>&#47;<a href=\"http:&#47;&#47;bsonspec.org\">BSON<&#47;a>)
  store. Additionally MongoDB offers facilities to index and search the collection
  of documents.\r\n\r\nIn conjunction with <a href=\"http:&#47;&#47;clojure.org\">Clojure<&#47;a>
  your are able to build a simple a quite powerful system to use event sourcing and
  CQRS."
wordpress_id: 184
wordpress_url: http://www.niclas-meier.de/?p=184
date: '2013-01-26 23:25:24 +0100'
date_gmt: '2013-01-26 22:25:24 +0100'
categories:
- Clojure
- MongoDB
tags: []
comments: []
---
<p>It was about a year ago when I stumbled about the concepts of <a href="http:&#47;&#47;martinfowler.com&#47;eaaDev&#47;EventSourcing.html">event sourcing<&#47;a> and <a href="http:&#47;&#47;martinfowler.com&#47;bliki&#47;CQRS.html">command query responsibility segregation<&#47;a> in a talk from <a href="http:&#47;&#47;codebetter.com&#47;gregyoung&#47;">Greg Young<&#47;a> at QCon 2011 in London which I watched on <a href="http:&#47;&#47;www.infoq.com&#47;presentations&#47;Events-Are-Not-Just-for-Notifications">InfoQ<&#47;a>. This challenged some things I knew for sure regarding how to store and manage data. </p>
<p>Fortunately I joined <a href="http:&#47;&#47;herolabs.com">HEROLABS<&#47;a> in December 2011 and due to the fact that we where starting a brand new product, I was able to play around with these concepts. Additionally we chose <a href="http:&#47;&#47;www.mongodb.org&#47;">MongoDB<&#47;a> instead of a relational database in our <a href="http:&#47;&#47;itunes.apple.com&#47;de&#47;app&#47;em-hero-2012&#47;id530513702?l=de&ls=1&mt=8">first project<&#47;a> as our main database management system. <a href="http:&#47;&#47;www.mongodb.org&#47;">MongoDB<&#47;a> is attributed to the NoSQL databases and is in the first place a big document (<a href="http:&#47;&#47;json.org">JSON<&#47;a>&#47;<a href="http:&#47;&#47;bsonspec.org">BSON<&#47;a>) store. Additionally MongoDB offers facilities to index and search the collection of documents.</p>
<p>In conjunction with <a href="http:&#47;&#47;clojure.org">Clojure<&#47;a> your are able to build a simple a quite powerful system to use event sourcing and CQRS.<a id="more"></a><a id="more-184"></a><br />
<h3>Creating events<&#47;h3><br />
Okay, lets start with the events: How to model events in Clojure? Basically there are two good choices, the first one is the Clojure standard namely maps. The second choice are records with protocols (e.g. <code>defrecord<&#47;code> and <code>defprotocol<&#47;code>) which are a little more turbocharged. So the protocol for our event may look like this:</p>
<pre>
(defprotocol EventProtocol<br />
  (id [this])<br />
  (type [this])<br />
  (created [this])<br />
  (aggregate-id [this])<br />
  (aggregate-version [this]))<br />
<&#47;pre></p>
<p>We have:</p>
<ul>
<li>an ID to identify the event.<&#47;li>
<li>an event type (e.g. <code>:user-created<&#47;code>).<&#47;li>
<li>a timestamp when the event was created&#47;occured. Notice that the event does not have a modification timestamp, because we do not modify events.<&#47;li>
<li>an ID of the aggregate where the events is related to.<&#47;li>
<li>a version identifier which tells us which aggregate version&#47;modification this event represents.<&#47;li><br />
<&#47;ul></p>
<p>Lets have a quick view on the theoretical part. What is the goal? We want to represent the state the application or of an (aggregate) entity to represented as a stream  of events, that is was <a href="http:&#47;&#47;martinfowler.com&#47;eaaDev&#47;EventSourcing.html">event sourcing<&#47;a> is all about. The work on event sourcing and CQRS is often closely tied to the <a href="http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Domain-Driven_Design">domain driven design (DDD)<&#47;a> ideas, so you often find references to <a href="http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Domain-Driven_Design">aggregates<&#47;a> or <a href="http:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Domain-Driven_Design">aggregate roots<&#47;a>. Aggregates are one of the building blocks of DDD and are similar to entities.<br />
So if you take a look at the defined protocol you will notice, that we have a minimal set of properties defined for a event. The relation to the aggregate is defined by the <code>aggregate-id<&#47;code> and we are able to order the events by the <code>aggregate-version<&#47;code>.</p>
<p>To bring the events in Clojure to life we define a record like this:</p>
<pre>
(defrecord Event [_id _aid _t _c _v]<br />
  EventProtocol<br />
  (id [_] _id)<br />
  (type [_] _t)<br />
  (created [_] _c)<br />
  (aggregate-id [_] _aid)<br />
  (aggregate-version [_] _v))<br />
<&#47;pre></p>
<p>The first question may be: Why these ugly names (like <code>_id<&#47;code>, <code>_aid<&#47;code>, <code>_t<&#47;code>, <code>_c<&#47;code> or <code>_v<&#47;code>)? I already mentioned MongoDB and this relates to my target implementation on MongoDB (I will explain the idea behind this a little later) and to be honest: This source code relates to my blog entry and I am not planning to create a generic event sourcing library for Clojure, so I decided to make my life a little easier here.</p>
<p>To create new events we may define a function like this:</p>
<pre>
(defn new-event<br />
  ([type aggregate-id] (new-event type aggregate-id nil))<br />
  ([type aggregate-id payload]<br />
    (map->Event (assoc payload<br />
                  :_aid aggregate-id<br />
                  :_t type<br />
                  :_c (now)))))<br />
<&#47;pre></p>
<p>To create a new event like the creation of a new user we may call:</p>
<pre>
(clj-eventsourcing.event&#47;new-event :user-created "5050480d3004e17b14ecb3fe" {:user-name "niclas"})<br />
<&#47;pre></p>
<p>and receive this record:</p>
<pre>
#clj_eventsourcing.event.Event{:_id nil, :_aid "5050480d3004e17b14ecb3fe", :_t :user-created, :_c #<datetime 2012-09-12T08:34:36.331Z>, :_v nil, :user-name "niclas"}<br />
<&#47;datetime><&#47;pre></p>
<p>You see that the payload <code>{:user-name "niclas"}<&#47;code> is attached to the record even when the field was not defined in the <code>defrecord<&#47;code> but if you check:</p>
<pre>
(instance? Event (clj-eventsourcing.event&#47;new-event :user-created "5050480d3004e17b14ecb3fe" {:user-name "niclas"}))<br />
<&#47;pre><br />
As you can see, this evaluates to <code>true<&#47;code>, so the instance returned is still an <code>Event<&#47;code>.</p>
<h3>Storing events<&#47;h3><br />
Creating events is nice, but if the events stay ephemeral they are of no use to your application. To store events we may define this preliminary protocol.</p>
<pre>
(defprotocol EventStore<br />
  (version-from [this aggregate-id])<br />
  (store-events-into [this version events])<br />
  (load-events-from [this aggregate-id]))<br />
<&#47;pre><br />
and a very simplistic implementor for MongoDB</p>
<pre>
(deftype MongoStore [collection]<br />
  clj_eventsourcing.store.EventStore<br />
  (version-from [_ aggregate-id] (version collection aggregate-id))<br />
  (store-events-into [_ version events] (store collection version events))<br />
  (load-events-from [_ aggregate-id] (load collection aggregate-id))<br />
  java.lang.Object<br />
  (toString [this] (str "<#MongoStore: " collection ">")))<br />
<&#47;pre><br />
which will dispatch the calls to the protocol to dedicated functions merging his internal state (the MongoDB collection to use) with the call parameter.</p>
<p>Let's have a quick look at the simplest of the three functions which should be <code>version-from<&#47;code>, unfortunately this leads to some basics first.</p>
<h4>Versions and optimistic locking<&#47;h4><br />
One important part of storing an event is to assign a version to the event to create an ordering. This is very important when you want to project events into a data structure. If you do not know is a the value of a field was first 'A' then 'B' or vice versa is bad.</p>
<p>How do we now assign versions? Unfortunately this is not an easy task in a distributed environment with only a MongoDB. If you use a SQL database you may use a sequence, <code>SELECT &hellip; FOR UPDATE<&#47;code> clause or an auto-increment field, but the MongoDB does not provide a similar mechanism.</p>
<p>For this example I choose a quite simple strategy. As version I used (positive) integers starting at one. When inserting events I will fetch the current version out of the database and assign new versions to the events by simply increasing the version (by one). Additionally I create a unique index for the events collection containing the aggregate ID (<code>_aid<&#47;code>) and the version (<code>:_v<&#47;code>) field. If e.g. another process is doing the same in parallel we will have overlapping versions and MongoDB will raise an error when the second one tries to insert the event(s).</p>
<p>Using this simple strategy we have an optimistic locking, where no node need to lock down the whole collection (or even worse database) to make sure that no one else updated the data while he was working on them. We can take this even one step further by supplying the version of the aggregate in use back to the <code>(store-events-into &hellip;)<&#47;code> function of the protocol. </p>
<p>You can find a simple realization of the <code>version-from<&#47;code> function on my <a href="https:&#47;&#47;github.com&#47;niclasmeier&#47;clj-eventsourcing&#47;blob&#47;master&#47;src&#47;clj_eventsourcing&#47;store&#47;mongo.clj">github repository.<&#47;a></p>
<h4>Inserting into MongoDB<&#47;h4><br />
The insertion of the events is now very simple. Provided we have a function that adds the version to the events you will have something like:</p>
<pre>
(defn store [collection version events]<br />
  (insert-batch collection (enrich-events version events))<br />
<&#47;pre></p>
<p>The only problem is that you have no safety net on this one. You want to check some constraints like:</p>
<ul>
<li>If the version is only a number, you should make sure that all events refer to the same aggregate<&#47;li>
<li>If the version is a map from aggregate ID to a number, you should make sure that you have versions for all aggregates referred by the events.<&#47;li>
<li>If an Exception about violating the unique index on the MongoDB collection is thrown, it might be a good idea converting it into something more useful (e.g. a different exception type)<&#47;li><br />
<&#47;ul></p>
<h3>Loading events<&#47;h3><br />
Loading events on the other hand side is very simple, now we known how the documents should look like:</p>
<pre>
(defn load [collection aggregate-id]<br />
  (with-collection collection<br />
    (where {:_aid aggregate-id})<br />
    (sort {:_v 1})))<br />
<&#47;pre><br />
Simply fetching all event documents from the MongoDB ordered by the version.</p>
<h3>Putting it together<&#47;h3><br />
Creating, loading and storing events with Clojure and storing them into MongoDB is not that hard and requires very lithe source code. You may use Protocols and Records to get a little bit more structure into this, but the initial event sourcing system used at HEROLABS was relying on Clojure maps and works fine. </p>
<p>Unfortunately we are far from done yet. Working on event streams is harder than fetching data from a business "object" (they will be maps or Records in Clojure). So the next step will be to explore how to project the events into data structures or operations, so that</p>
<pre>
[{:_aid 1 :_v 1 :_t :set-name :first-name "Niclas" :last-name "Meier"}<br />
{:_aid 1 :_v 2 :_t :add-blog :url "http:&#47;&#47;www.niclas-meier.de&#47;"}]<br />
<&#47;pre><br />
will get</p>
<pre>
{:_aid 1 :_v 2 :first-name "Niclas" :last-name "Meier" :url "http:&#47;&#47;www.niclas-meier.de&#47;"}<br />
<&#47;pre><br />
or at least something like this, so stay tuned for part two. In the meantime you may check out some more source code at my <a href="https:&#47;&#47;github.com&#47;niclasmeier&#47;clj-eventsourcing">github repository<&#47;a>, but be aware that this is only an implementation sketch and not fully implemented.</p>
