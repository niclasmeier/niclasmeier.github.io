---
layout: post
status: publish
published: true
title: Alternate Futures and Promises for Clojure
author:
  display_name: Niclas Meier
  login: niclas
  email: mail@niclas-meier.de
  url: http://www.niclas-meier.de
author_login: niclas
author_email: mail@niclas-meier.de
author_url: http://www.niclas-meier.de
excerpt: |-
  At the moment I am experimenting with various techniques to speed up some update queries from our <a href="http:&#47;&#47;www.emhero2012.com">client<&#47;a>. One important element of this efforts is making things parallel. E.g. to compute a list update of deltas for the client we need to compare the version of the user on the client and in the database and we need the user data at some other places on the delta computation. So it would be a good idea to initiate the loading of the user data asynchronous right at the beginning of the request processing. While the user data is loaded we can load&#47;compute some other stuff (e.g. we need some data about the <a href="http:&#47;&#47;de.uefa.com&#47;uefaeuro&#47;index.html">competition<&#47;a> and the matches). When all the required information is present continue the rest of the the job (e.g. generate some XML or JSON).

  Futures implementations like <a href="http:&#47;&#47;docs.oracle.com&#47;javase&#47;6&#47;docs&#47;api&#47;java&#47;util&#47;concurrent&#47;Future.html"><code>java.util.concurrent.Future<&#47;code><&#47;a>, <a href="http:&#47;&#47;www.scala-lang.org&#47;archives&#47;downloads&#47;distrib&#47;files&#47;nightly&#47;docs&#47;library&#47;scala&#47;concurrent&#47;Future.html"><code>scala.concurrent.Future<&#47;code><&#47;a> or <a href="http:&#47;&#47;clojure.github.com&#47;clojure&#47;clojure.core-api.html#clojure.core&#47;future"><code>clojure.core&#47;future<&#47;code><&#47;a> seem to be the weapon of choice for this.

  Due to the fact that our backend is written in <a href="http:&#47;&#47;clojure.org&#47;">Clojure<&#47;a> I took a closer look at the Clojure Future implementation <code>clojure.core&#47;future<&#47;code>. The Clojure implementation is pretty basic and very similar the the underlying Java implementation. This isn't bad, but rather unsatisfying for a language emphasizing on concurrency like Clojure.
wordpress_id: 156
wordpress_url: http://www.niclas-meier.de/?p=156
date: '2012-06-01 22:30:04 +0200'
date_gmt: '2012-06-01 21:30:04 +0200'
categories:
- Java
- Scala
- Clojure
tags: []
comments:
- id: 4231
  author: Andrew Cowper
  author_email: web@slothrop.net
  author_url: ''
  date: '2012-06-02 14:53:47 +0200'
  date_gmt: '2012-06-02 13:53:47 +0200'
  content: "You may not want your implementation relying on third party library, but
    it might be worth  looking at the Futures in Google's Guava library. \r\n\r\nI
    think a lot of this stuff could be implemented as pretty thin wrappers around
    the ListenableFuture and SettableFuture."
- id: 4232
  author: Brandon Bloom
  author_email: Brandon@brandonbloom.name
  author_url: ''
  date: '2012-06-02 17:57:11 +0200'
  date_gmt: '2012-06-02 16:57:11 +0200'
  content: "Glad someone else is thinking about this. Thanks for sharing your thoughts.\r\n\r\nOne
    thing that deserves additional thought is the failure model. Existing promises
    in the :failure state rethrow upon deref. Have you considered that approach?\r\n\r\nI
    bring this up bacause I've worked with various calling conventions in async JavaScript.
    In particular, the success&#47;failure&#47;completed trio common in th jQuery
    world has been far more resistant to composition than the Node.js (error, results...)
    callback. See the Async.js library. Any new implementation of futures should have
    elegant implementations of all the combinators in there.\r\n\r\nLastly, the .Net
    world is also worth studying here. Take a look at \"parallel extensions\". There
    are some interesting ideas bout error handling and cancelation. Beyond that, the
    \"reactive extensions\" are built on the parallel ones. The has been some discussion
    on the clojure wiki about observables and reactive, but I think it is important
    to get futures right first.\r\n\r\nSorry about typos &amp; lack of links. I'm
    n my iPad"
- id: 4233
  author: admin
  author_email: admin@niclas-meier.de
  author_url: ''
  date: '2012-06-02 21:56:41 +0200'
  date_gmt: '2012-06-02 20:56:41 +0200'
  content: "Thanks for the hint, I will take a closer look at the Guava library, looks
    interesting. Twitter has in it's util library a nice Future implementation too.
    \r\n\r\nIn our project we have a very nice and simple solution using the <code>pmap<&#47;code>
    function of Clojure."
- id: 4234
  author: Niclas Meier
  author_email: mail@niclas-meier.de
  author_url: http://www.niclas-meier.de
  date: '2012-06-02 22:02:06 +0200'
  date_gmt: '2012-06-02 21:02:06 +0200'
  content: "Rethrowing an exception in <code>:failiure<&#47;code> state sounds like
    an interesting idea. But I am not a big fan of exception at all. People tend to
    use them as fire and forget, so they get thrown and nobody takes care of them.\r\nOn
    the other hand side, there is no better way of signaling errors in your technical
    Infrastructure (like DB down)."
- id: 4235
  author: Chouser
  author_email: Chouser@n01se.net
  author_url: ''
  date: '2012-06-03 05:45:15 +0200'
  date_gmt: '2012-06-03 04:45:15 +0200'
  content: "I think you meant \"deliver\" instead of \"declare\". You may also be
    interested to know that clojurescript uses a convention of a leading dash for
    protocol methods that are otherwise named the same as a convenience function,
    so -status instead of status*\r\n\r\nBut regardless, this seems like a nice, carefully
    considered set of functions&mdash;I look forward to where you end up."
---
<p>At the moment I am experimenting with various techniques to speed up some update queries from our <a href="http:&#47;&#47;www.emhero2012.com">client<&#47;a>. One important element of this efforts is making things parallel. E.g. to compute a list update of deltas for the client we need to compare the version of the user on the client and in the database and we need the user data at some other places on the delta computation. So it would be a good idea to initiate the loading of the user data asynchronous right at the beginning of the request processing. While the user data is loaded we can load&#47;compute some other stuff (e.g. we need some data about the <a href="http:&#47;&#47;de.uefa.com&#47;uefaeuro&#47;index.html">competition<&#47;a> and the matches). When all the required information is present continue the rest of the the job (e.g. generate some XML or JSON).</p>
<p>Futures implementations like <a href="http:&#47;&#47;docs.oracle.com&#47;javase&#47;6&#47;docs&#47;api&#47;java&#47;util&#47;concurrent&#47;Future.html"><code>java.util.concurrent.Future<&#47;code><&#47;a>, <a href="http:&#47;&#47;www.scala-lang.org&#47;archives&#47;downloads&#47;distrib&#47;files&#47;nightly&#47;docs&#47;library&#47;scala&#47;concurrent&#47;Future.html"><code>scala.concurrent.Future<&#47;code><&#47;a> or <a href="http:&#47;&#47;clojure.github.com&#47;clojure&#47;clojure.core-api.html#clojure.core&#47;future"><code>clojure.core&#47;future<&#47;code><&#47;a> seem to be the weapon of choice for this.</p>
<p>Due to the fact that our backend is written in <a href="http:&#47;&#47;clojure.org&#47;">Clojure<&#47;a> I took a closer look at the Clojure Future implementation <code>clojure.core&#47;future<&#47;code>. The Clojure implementation is pretty basic and very similar the the underlying Java implementation. This isn't bad, but rather unsatisfying for a language emphasizing on concurrency like Clojure.<a id="more"></a><a id="more-156"></a>The Clojure Future API consists of these functions in the <code>clojure.core<&#47;code> namespace:</p>
<dl>
<dt><code>(future &hellip;)<&#47;code><&#47;dt></p>
<dd>Creates a future instance and executes the provided code.<&#47;dd></p>
<dt><code>(future-call  &hellip;)<&#47;code><&#47;dt></p>
<dd>Creates a future instance and executes a provided function. This function is used by the <code>(future &hellip;)<&#47;code> marco.<&#47;dd></p>
<dt><code>(future-cancel  &hellip;)<&#47;code><&#47;dt></p>
<dd>Cancels the further, if possible.<&#47;dd></p>
<dt><code>(future-cancelled?  &hellip;)<&#47;code><&#47;dt></p>
<dd>Returns <code>true<&#47;code> if future f is cancelled<&#47;dd></p>
<dt><code>(promise  &hellip;)<&#47;code><&#47;dt></p>
<dd>Returns a promise object that can be read with <code>deref<&#47;code>&#47;<code>@<&#47;code>, and set, once only.<&#47;dd></p>
<dt><code>(deliver  &hellip;)<&#47;code><&#47;dt></p>
<dd>Delivers the supplied value to the promise, releasing any pending derefs. A subsequent call to deliver on a promise will throw an exception.<&#47;dd><br />
<&#47;dl></p>
<p>This is a small but sufficient API. The <code>promise<&#47;code>&#47;<code>deliver<&#47;code> functions are relatively new and having a <i>"Alpha - subject to change"<&#47;i> note.</p>
<p>So how does this work:</p>
<pre>
(let [f (future (do (java.lang.Thread&#47;sleep 42))]<br />
	(println "value:" @f)<br />
)<br />
<&#47;pre></p>
<p>You simply wrap the code you want the be execute in parallel in the <code>(future &hellip;)<&#47;code> macro and you get a future datatype which reifies <code>clojure.lang.IDeref<&#47;code>, <code>clojure.lang.IBlockingDeref<&#47;code>, <code>clojure.lang.IPending<&#47;code> and <code>java.util.concurrent.Future<&#47;code>. This has some pretty nice effects. The future can be read with <code>@<&#47;code>&#47;<code>deref<&#47;code> and you may use it like any other Java future.</p>
<p>Not so nice is that you have the <code>(future-cancel  &hellip;)<&#47;code> function or the <code>cancel()<&#47;code> method in the <code>java.util.concurrent.Future<&#47;code> interface. So what is so bad about this? First: This is a mutating function on the reference, so if you pass your future running a important job to someone else, he may simply cancel this job and you can't prevent this. Second: What happens when you cancel the job? When your long running job has a database update at the end, will the update be executed? Will truncations be rolled back? Connections closed?</p>
<p>That you don't get noticed when the future processing is finished is somewhat sad too. Due to the fact the functions are first class citizens and closures are all around, it would be great if you could provide e.g. a function as callback when the future was successfully finished. The Scala scala.concurrent.Future implementation offers method like <code>onComplete(&hellip;)<&#47;code>, <code>onSuccess(&hellip;)<&#47;code> or <code>onFailure(&hellip;)<&#47;code> where you can supply these kind of handlers. What is also great on Scala Futures is that they offer methods like <code>flatMap<&#47;code>, etc. which are used for the Scala <code>for<&#47;code> comprehension. This enables you to do stuff like this:</p>
<pre>
for (a <- someExpensiveComputation()<br />
     b <- hugeLoadFromDatabase())<br />
  yield merge (a, b)<br />
<&#47;pre></p>
<p>This would execute in parallel the <code>someExpensiveComputation<&#47;code> and <code>hugeLoadFromDatabase<&#47;code> and both results are available in the list comprehension. </p>
<p>The last flaw I see is, that you have no control about the execution. Clojure (1.3) uses the same <code>Executor<&#47;code> used for <code>(send-off &hellip;)<&#47;code> to execute the future but you cant't influence this and you have no control on the executor. In Java there is lot's of boilerplate, because you'll have to create an <code>Executor<&#47;code> and submit a <code>Runnable<&#47;code> manually, therefore you have the full control. Scala had also this flaw hiding the execution of a Future but with the rework of Futures and Promises in Scala (<a href="http:&#47;&#47;docs.scala-lang.org&#47;sips&#47;pending&#47;futures-promises.html">SIP-14<&#47;a> an <code>ExecutionContext<&#47;code> was introduced, which solves this issue.</p>
<p>So let's explore how we can build a Future &#47; Promise library in Clojure where that does not have these issues.</p>
<hr &#47;>
<h3>The goal<&#47;h3><br />
My goal would be to write something like this</p>
<pre>
(future (load-data-from-somewhere ctx)<br />
	(on-success [v] (initiate-process v))<br />
	(on-failure [cause] (warn cause (format "Unable to load data, retrying in %s seconds" retry-threshold))))<br />
<&#47;pre></p>
<p>it would be also nice to do something like </p>
<pre>
(let [f (for [order-data (future (fetch-order oid))<br />
              customer-data (future (fetch-customer cid))] (merge-data order-data customer-data))]<br />
(on-success f [data] (send-email data)))<br />
<&#47;pre></p>
<p>This would return a future that aggregates the result of both fetch requests. You would be able to register for the <code>:on-success<&#47;code> event and perform an operation if wanted.</p>
<p>Lets see how far we get ...</p>
<h3>Definition of Terms<&#47;h3></p>
<p>First - as some kind of Homework - I want to define what a Future and a Promise is for me (and yes this is heavily inspired by other sources - e.g. some talks by <a href="https:&#47;&#47;twitter.com&#47;#!&#47;viktorklang">Viktor Klang<&#47;a> or the <a href="http:&#47;&#47;docs.scala-lang.org&#47;sips&#47;pending&#47;futures-promises.html">SIP-14<&#47;a>).</p>
<dl>
<dt>Future<&#47;dt></p>
<dd>A Future is a read handle to a value that may be come available some times later. A Future may be read many times.<&#47;dd></p>
<dt>Promise<&#47;dt></p>
<dd>A Promise is a write handle for a value that will be available in the later process. You may pass the promise out to someone else to provice a reference to a value that you don't have yet. A promise may be written only one.<&#47;dd><br />
<&#47;dl></p>
<p>A Future and a Promise - at least in this example - will have this three states:</p>
<dl>
<dt><code>:pending<&#47;code><&#47;dt></p>
<dd>The Future&#47;Promise has not yet received a value.<&#47;dd></p>
<dt><code>:success<&#47;code><&#47;dt></p>
<dd>The Promise&#47;Future has received the a value and the previous computation has to considered successful.<&#47;dd></p>
<dt><code>:failure<&#47;code><&#47;dt></p>
<dd>The Promise&#47;Future has received the a value and the previous computation failed e.g. threw an Exception.<&#47;dd><br />
<&#47;dl></p>
<h3>Promise - the basics<&#47;h3></p>
<p>So let's look at some code and start with some <a href="https:&#47;&#47;github.com&#47;niclasmeier&#47;clj-future">code<&#47;a>. You will find a somewhat working <a href="https:&#47;&#47;github.com&#47;niclasmeier&#47;clj-future">demo project on github.com<&#47;a></p>
<p>First I want to define some artifacts needed for a Promise.</p>
<pre>
(defn promise [] &hellip;)<br />
(defn status [promise] &hellip;)<br />
<&#47;pre></p>
<p>I guess these are the first very functions needed for a promise. The first one <code>(promise &hellip;)<&#47;code> is a basic factory function for the handle and the <code>(status promise)<&#47;code> returns the status. The promise will be a <code>ref<&#47;code> data type, so the value may be obtained by using <code>deref<&#47;code>.To set the value we will define functions like:</p>
<pre>
(defn success [promise value] &hellip;)<br />
(defn failure [promise cause] &hellip;)<br />
<&#47;pre></p>
<p>These two function will replace the <code>(declare &hellip;)<&#47;code> function of the Clojure original. The <code>(success &hellip;)<&#47;code> function will set the Promise value to the passed value and the state of the promise will change to <code>:success<&#47;code>. The <code>(failure &hellip;)<&#47;code> function will indicate that the computation that gave out the Promise failed, the value of the Promise is reflects the cause for the failure and the state of the promise will change to <code>:failed<&#47;code>. Both functions will throw an exception if someone tries to write to the Promise a second time.</p>
<p>How do we implement the handle. I defined a Clojure protocol to have an interface:</p>
<pre>
(defprotocol Promise<br />
  (future* [promise])<br />
  (try-success* [promise x])<br />
  (try-failure* [promise x])<br />
  (status* [promise])<br />
  )<br />
<&#47;pre></p>
<p>Pretty simple I guess so here is how it works:</p>
<dl>
<dt><code>(future* [promise])<&#47;code><&#47;dt></p>
<dd>This function will create a future for this promise. So someone create a promise and pass it to an asynchronous process while passing out a future to another process that will receive the value when the value was written to the promise. In fact in my variant it simply returns itself.<&#47;dd></p>
<dt><code>(try-success* [promise x])<&#47;code><&#47;dt></p>
<dd>This function try to write a value to the promise and switch to the <code>:success<&#47;code> state<&#47;dd></p>
<dt><code>(try-failure* [promise x])<&#47;code><&#47;dt></p>
<dd>This function try to write a value to the promise and switch to the <code>:success<&#47;code> state<&#47;dd></p>
<dt><code>(status* [promise])<&#47;code><&#47;dt></p>
<dd>This function returns the current state of the promise.<&#47;dd><br />
<&#47;dl></p>
<p>Why the <code>*<&#47;code> at the end of the function name. I use this convention to indicate some private&#47;delegate functions. E.g. the <code>(success &hellip;)<&#47;code> function will simply delegate to the <code> (try-success* [promise x] &hellip;)<&#47;code>. The main difference is that both <code>(try-&hellip;)<&#47;code> method returns a boolean value indicating a successful operation while <code>(success &hellip;)<&#47;code> returns the supply value and will throw an exception if an error occurs.</p>
<p>The next step is to create an instance:</p>
<pre>
(defn- notify [x &amp; listeners]<br />
  (doseq [listener listeners :when listener] (listener x)))</p>
<p>(defn- try-complete-promise [^java.util.concurrent.CountDownLatch d v s x complete variable]<br />
  (if (pos? (.getCount d))<br />
    (if (compare-and-set! v nil [s x])<br />
      (do<br />
        (.countDown d)<br />
        (apply notify x (concat @complete @variable))<br />
        true)<br />
      false)))</p>
<p>(defn promise []<br />
  (let [d (java.util.concurrent.CountDownLatch. 1)<br />
        v (atom nil)<br />
        on-complete (create-list on-complete)<br />
        on-success (create-list on-success)<br />
        on-failure (create-list on-failure)]<br />
    (reify<br />
      Promise<br />
      (future* [this] this)<br />
      (try-success* [_ x] (try-complete-promise d v :success x on-complete on-success))<br />
      (try-failure* [_ x] (try-complete-promise d v :failure x on-complete on-failure))<br />
      (status* [this] (if (.isRealized this) (first @v) :pending ))<br />
      clojure.lang.IDeref<br />
      (deref [_] (.await d) (second @v))<br />
      clojure.lang.IBlockingDeref<br />
      (deref<br />
        [_ timeout-ms timeout-val]<br />
        (if (.await d timeout-ms java.util.concurrent.TimeUnit&#47;MILLISECONDS)<br />
          (second @v)<br />
          timeout-val))<br />
      clojure.lang.IPending<br />
      (isRealized [this]<br />
        (zero? (.getCount d)))<br />
      )))<br />
<&#47;pre></p>
<p>The previously announced factory function simply uses <code>reify<&#47;code> to create a new instance. The state is held as closure by the defined <code>let<&#47;code> bindings. Primarily important are <code>d<&#47;code> - a <code>CountDownLatch<&#47;code> to prevent multiple writes and handle synchronization - and <code>v<&#47;code> an atom holding the value. The value of <code>v<&#47;code> will be an array containing the status (the first element) and the supplied value (the second element).</p>
<p>To read the value of the Promise the reified instance also implements <code>clojure.lang.IDeref<&#47;code> and <code>clojure.lang.IBlockingDeref<&#47;code>. This offers the possibility to read the promise by using <code>deref<&#47;code> or the <code>@<&#47;code> reader macro. This works exactly like the original Clojure promise and to be honest the source is also very similar &hellip; ;-)</p>
<p>Additionally there is the possibility to pass some listener functions which will be invoked with the value (or cause) when the promise is written. This will be used to the Future realization later on.</p>
<p>If you are still curious have a look at the <a href="2012&#47;06&#47;from-promises-to-futures&#47;">next post<&#47;a>.</p>
